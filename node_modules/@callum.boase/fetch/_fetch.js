//Only load node-fetch in nodeJs environment
//If we're running this file in browser, we'll use the browser's fetch API which is built-in
//If bundling this module for browser usage, skip bundling node-fetch
//Eg if bundling using browserify add flag "--external node-fetch" when running "browserify..."
//  The bundling will assume node-fetch is already avaialble in the environment, which it will NOT be
//  So the if statement ensures we don't try to use the non-existent node-fetch
if(inBrowser()){
    fetch = window.fetch;
} else {
    var fetch = require('node-fetch');
}

function inBrowser(){
    try {
        window.fetch;
        return true
    } catch (err){
        return false;
    }
}

const _fetch = {
    
    delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    },

    tools: {
        exponentialBackoff(attempt){
            return Math.pow(2, attempt - 1) * 1000; //1000, 2000, 4000 etc
        }
    },

    defaults: {

        retryDelay(attempt, mostRecentErr){
            if(mostRecentErr.details.response.status === 429){
                return Math.pow(2, attempt - 1) * 1000; //Exponential backoff same as _fetch.tools.exponentialBackoff
            } else {
                return 1000;
            }
        },

        retryOn(attempt, err){
            if(err.details && err.details.response && (err.details.response.status >= 500 || err.details.response.status === 429)){
                return true;
            } else {
                return false;
            }
        }
    },

    async wrapper(url, options = {}, helperData = {}) {

        try {

            const response = await fetch(url, options);

            const text = await response.text();

            //You can only consume response body methods once
            //So we get text above and then convert text to JSON if applicable
            let json = null;
            if(isJson(text)){
                json = JSON.parse(text);
            } 

            if(response && response.ok){
                return {url, options, response, helperData, json, text}
            }

            let err = new Error(`Successful http request but response.ok === false. Code: ${response.status}, Text: ${text}`);
            err.details = {url, options, response, helperData, json, text};
            throw err;
       
        } catch(err) {//This runs with either the above manually thrown error, or with fetch-API generated errors
            !err.details ? err.details = {url, options, helperData} : err.datails;
            throw err;
        }

        function isJson(text){
            try {
                JSON.parse(text);
                return true;
            } catch(err){
                return false;
            }
        }

    },

    async one (settings = {url, options, helperData, retries, retryDelay, retryOn}) {

        if(typeof settings !== 'object' || !settings.url) throw new Error('Invalid argument when calling _fetch.one. You must call _fetch.one with an object (settings), containing at-minimum: settings = {url: string}');

        if (!settings.options) settings.options = {method: 'GET'};
        if (settings.options && !settings.options.method) settings.options.method = 'GET';

        if (!settings.retries && settings.retries !== 0) settings.retries = 5;

        if(typeof settings.retryDelay !== 'function' && typeof settings.retryDelay !== 'number'){
            settings.retryDelay = this.defaults.retryDelay;
        }   

        if (typeof settings.retryOn !== 'function'){
            settings.retryOn = this.defaults.retryOn;
        }
    
        //thanks to: https://dev.to/ycmjason/javascript-fetch-retry-upon-failure-3p6g
        let mostRecentErr;

        for(let i = 0; i <= settings.retries; i++){
            try {

                if(i > 0) {
                    let retryDelay;

                    if(typeof settings.retryDelay === 'function') {
                        retryDelay = settings.retryDelay(i, mostRecentErr)
                    } else {
                        retryDelay = settings.retryDelay;
                    }

                    await this.delay(retryDelay);
                }
                return await this.wrapper(settings.url, settings.options, settings.helperData);
            
            } catch (err){

                const isLastRetry = i === settings.retries;
                if(isLastRetry) throw err;

                const shouldRetry = await settings.retryOn(i, err);
                if(!shouldRetry) throw err;

                mostRecentErr = err;

                console.log(`failed fetch ${settings.options.method} to ${settings.url}. Code: ${err.details && err.details.response ? err.details.response.status : ""}. Attempt ${i}. Retrying...`);
            }
        }
    },

    async many (settings = {requests, delayMs, progressCbs}) {

        if(!settings.delayMs) settings.delayMs = 125;
    
        let promises = [];
        settings.requests.forEach( (request, i) => {
            const promise = (async () => {
                await this.delay(i*settings.delayMs);
                const fetchResult = await this.one({
                    url: request.url, 
                    options: request.options,
                    retries: request.retries, 
                    retryDelay: request.retryDelay,
                    retryOn: request.retryOn,
                    helperData: {request, delayMs: i*settings.delayMs, i},
                });
                progress++
    
                if(settings.progressCbs && settings.progressCbs.length){
                    settings.progressCbs.forEach(progressCb => {
                        progressCb(progress, len, fetchResult)
                    });
                }
    
                return fetchResult;
            })();
            promises.push(promise);
        });
    
        const len = promises.length;
        let progress = 0;
    
        return Promise.allSettled(promises);
    }

}

if(typeof require != 'undefined') module.exports = _fetch;