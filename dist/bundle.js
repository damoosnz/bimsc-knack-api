(() => {
    var R = Object.create; var k = Object.defineProperty; var K = Object.getOwnPropertyDescriptor; var C = Object.getOwnPropertyNames; var _ = Object.getPrototypeOf, x = Object.prototype.hasOwnProperty; var b = (r => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(r, { get: (o, e) => (typeof require < "u" ? require : o)[e] }) : r)(function (r) { if (typeof require < "u") return require.apply(this, arguments); throw Error('Dynamic require of "' + r + '" is not supported') }); var y = (r, o) => () => (o || r((o = { exports: {} }).exports, o), o.exports); var O = (r, o, e, t) => { if (o && typeof o == "object" || typeof o == "function") for (let a of C(o)) !x.call(r, a) && a !== e && k(r, a, { get: () => o[a], enumerable: !(t = K(o, a)) || t.enumerable }); return r }; var g = (r, o, e) => (e = r != null ? R(_(r)) : {}, O(o || !r || !r.__esModule ? k(e, "default", { value: r, enumerable: !0 }) : e, r)); var P = y((d, T) => { "use strict"; var F = function () { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }, p = F(); T.exports = d = p.fetch; p.fetch && (d.default = p.fetch.bind(p)); d.Headers = p.Headers; d.Request = p.Request; d.Response = p.Response }); var S = y((de, I) => { q() ? w = window.fetch : w = P(); var w; function q() { try { return window.fetch, !0 } catch { return !1 } } var H = { delay(r) { return new Promise(o => setTimeout(o, r)) }, tools: { exponentialBackoff(r) { return Math.pow(2, r - 1) * 1e3 } }, defaults: { retryDelay(r, o) { return o.details.response.status === 429 ? Math.pow(2, r - 1) * 1e3 : 1e3 }, retryOn(r, o) { return !!(o.details && o.details.response && (o.details.response.status >= 500 || o.details.response.status === 429)) } }, async wrapper(r, o = {}, e = {}) { try { let a = await w(r, o), s = await a.text(), n = null; if (t(s) && (n = JSON.parse(s)), a && a.ok) return { url: r, options: o, response: a, helperData: e, json: n, text: s }; let i = new Error(`Successful http request but response.ok === false. Code: ${a.status}, Text: ${s}`); throw i.details = { url: r, options: o, response: a, helperData: e, json: n, text: s }, i } catch (a) { throw a.details ? a.datails : a.details = { url: r, options: o, helperData: e }, a } function t(a) { try { return JSON.parse(a), !0 } catch { return !1 } } }, async one(r = { url, options, helperData, retries, retryDelay, retryOn }) { if (typeof r != "object" || !r.url) throw new Error("Invalid argument when calling _fetch.one. You must call _fetch.one with an object (settings), containing at-minimum: settings = {url: string}"); r.options || (r.options = { method: "GET" }), r.options && !r.options.method && (r.options.method = "GET"), !r.retries && r.retries !== 0 && (r.retries = 5), typeof r.retryDelay != "function" && typeof r.retryDelay != "number" && (r.retryDelay = this.defaults.retryDelay), typeof r.retryOn != "function" && (r.retryOn = this.defaults.retryOn); let o; for (let e = 0; e <= r.retries; e++)try { if (e > 0) { let t; typeof r.retryDelay == "function" ? t = r.retryDelay(e, o) : t = r.retryDelay, await this.delay(t) } return await this.wrapper(r.url, r.options, r.helperData) } catch (t) { if (e === r.retries || !await r.retryOn(e, t)) throw t; o = t, console.log(`failed fetch ${r.options.method} to ${r.url}. Code: ${t.details && t.details.response ? t.details.response.status : ""}. Attempt ${e}. Retrying...`) } }, async many(r = { requests, delayMs, progressCbs }) { r.delayMs || (r.delayMs = 125); let o = []; r.requests.forEach((a, s) => { let n = (async () => { await this.delay(s * r.delayMs); let i = await this.one({ url: a.url, options: a.options, retries: a.retries, retryDelay: a.retryDelay, retryOn: a.retryOn, helperData: { request: a, delayMs: s * r.delayMs, i: s } }); return t++, r.progressCbs && r.progressCbs.length && r.progressCbs.forEach(c => { c(t, e, i) }), i })(); o.push(n) }); let e = o.length, t = 0; return Promise.allSettled(o) } }; typeof b < "u" && (I.exports = H) }); var m = y((fe, D) => {
        var u = S(); function z(r) {
            o(), r.auth === "view-based" ? this.headers = { "X-Knack-Application-ID": r.applicationId, "X-Knack-REST-API-Key": "knack", Authorization: typeof r.userToken == "string" ? r.userToken : "", "Content-Type": "application/json" } : r.auth === "object-based" && (this.headers = { "X-Knack-Application-ID": r.applicationId, "X-Knack-REST-API-Key": r.apiKey, "Content-Type": "application/json" }), this.urlBase = "https://api.knack.com/v1", this.remoteLogin = async function (e = { email, password }) { return await u.one({ url: `${this.urlBase}/applications/${this.headers["X-Knack-Application-ID"]}/session`, options: { method: "POST", body: JSON.stringify({ email: e.email, password: e.password }), headers: { "Content-Type": "application/json" } } }) }, this.login = async function (e = { email, password }) { if (e.email && e.password) { let a = (await this.remoteLogin(e)).json.session.user.token; return this.headers.Authorization = a, a } else throw new Error("You did not specify one/both of email and password in settings object. Could not log in") }, this.validateSession = async function (e = { userToken, userRoleCheck }) { if (typeof e.userToken != "string") throw new Error("You must provide a settings object with at least a userToken (string) to validateSession()"); try { let a = (await u.one({ url: `${this.urlBase}/session/token`, options: { method: "GET", headers: { Authorization: e.userToken, "x-knack-application-id": this.headers["X-Knack-Application-ID"] } } })).json?.session; if (!a) throw new Error("No session found"); if (a.user.status !== "current") throw new Error("Valid user but session not current."); if (a.user.account_status !== "active") throw new Error("Valid user but status not active."); if (a.user.approval_status !== "approved") throw new Error("Valid user but approval status is not approved."); if (e.userRoleCheck && !a.user.profile_keys.includes(e.userRoleCheck)) throw new Error("Valid user but does not include the specified user role."); return !0 } catch { return !1 } }, this.url = function (e = { scene, view, object, recordId }) { let t = this.urlBase; return r.auth === "view-based" ? t += `/pages/${e.scene}/views/${e.view}/records/` : r.auth === "object-based" && (t += `/objects/${e.object}/records/`), e.recordId && (t += e.recordId), t }, this.getRetries = function (e) { return typeof e == "number" ? e : 5 }, this.setup = function (e, t) { let a = ""; r.auth === "view-based" ? a = this.url({ scene: t.scene, view: t.view, recordId: t.recordId }) : r.auth === "object-based" && (a = this.url({ object: t.object, recordId: t.recordId })); let s = { method: e, headers: this.headers }; t.body && (s.body = JSON.stringify(t.body)); let n = this.getRetries(t.retries); return { url: a, options: s, retries: n, helperData: t.helperData } }, this.single = async function (e, t) { let a = this.setup(e, t); return await u.one(a) }, this.many = async function (e, t) { if (e === "GET") return console.log("knackAPI.many is only for POST, PUT and DELETE"); let a = []; t.records.forEach(i => { let c = { view: t.view, scene: t.scene, object: t.object, retries: t.retries }; e !== "DELETE" && (c.body = i), e !== "POST" && (c.recordId = i.id), a.push(this.setup(e, c)) }), t.resultsReport && this.tools.manyResultsReport.remove(t.resultsReport); let s = this.progressCbsSetup(t), n = await u.many({ requests: a, delayMs: 125, progressCbs: s }); return n.settings = t, n.summary = this.tools.manyResultsReport.calc(n), t.resultsReport && this.tools.manyResultsReport.create(t.resultsReport, n), n }, this.progressCbsSetup = function (e) { let t = []; return e.progressBar && (this.tools.progressBar.create(e.progressBar), t.push((a, s, n) => { this.tools.progressBar.update(e.progressBar.id, a, s) })), e.progressCbs && e.progressCbs.length && e.progressCbs.forEach(a => t.push(a)), t }, this.get = async function (e = { view, scene, object, recordId, helperData }) { return await this.single("GET", e) }, this.post = async function (e = { view, scene, object, body, helperData, retries }) { return await this.single("POST", e) }, this.put = async function (e = { recordId, view, scene, object, body, helperData, retries }) { return await this.single("PUT", e) }, this.delete = async function (e = { recordId, view, scene, object, helperData, retries }) { return await this.single("DELETE", e) }, this.getMany = async function (e = { view, scene, object, filters, rowsPerpage, startAtPage, maxRecordsToGet, helperData }, t = 1, a = { records: [], pages: [] }) { let s = this.setup("GET", e); t === 1 && e.startAtPage > 1 && (t = e.startAtPage); let n = e.maxRecordsToGet > 0 ? e.maxRecordsToGet : 1 / 0, i = e.rowsPerPage ? e.rowsPerPage : 1e3; s.url += `?page=${t}&rows_per_page=${i}`, e.format && (s.url += `&format=${e.format}`), e.filters && (s.url += `&filters=${JSON.stringify(e.filters)}`); let c = await u.one(s); return a.pages.push(c), c.json.records.map(f => a.records.push(f)), a.helperData = e.helperData, a.records.length > n && (a.records = a.records.splice(0, n)), a.records.length < n && c.json.current_page < c.json.total_pages ? await this.getMany(e, c.json.current_page + 1, a) : a }, this.putMany = async function (e = { records, view, scene, object, helperData, retries, progressBar, progressCbs, resultsReport }) { return await this.many("PUT", e) }, this.postMany = async function (e = { records, view, scene, object, helperData, retries, progressBar, progressCbs, resultsReport }) { return await this.many("POST", e) }, this.deleteMany = async function (e = { records, view, scene, object, helperData, retries, progressBar, progressCbs, resultsReport }) { return await this.many("DELETE", e) }, this.getFromReportView = async function (e = { view, scene, sceneRecordId, helperData, retries }) { if (r.auth !== "view-based") throw new Error("getFromReportView() only works when using view-based auth"); if (!e.view || !e.scene) throw new Error("getFromReportView() requires a view and scene. You did not specify one or both."); if (e.recordId) throw new Error(`getFromReportView() does not support recordId. Specify settings.sceneRecordId if you are trying to load a report on a child page that has the data source of "this page's record" or similar.`); let t = `${this.urlBase}/scenes/${e.scene}/views/${e.view}/report`; if (e.sceneRecordId) { let s = await this.getSceneSlug(e.scene); t += `?${s}_id=${e.sceneRecordId}` } let a = { url: t, options: { method: "GET", headers: this.headers }, retries: this.getRetries(e.retries), helperData: e.helperData }; return await u.one(a) }, this.tools = {
                progressBar: {
                    html(e) {
                        return $(`
                    <div id="${e}" style="margin-bottom: 10px;">
                        <span class="before-progress-bar" style="margin-right: 5px;"><em><strong>Processing records</em></strong></span>
                        <progress id="progressBar" value="0" max="100"></progress>
                        <span class="after-progress-bar" style="margin-left: 5px;" id="progressText">Initialising...</span>
                    </div>
                `)
                    }, update(e, t, a) { $(`#${e} #progressBar`).val(Math.round(t / a * 100)), $(`#${e} #progressText`).text(`${t}/${a}`) }, create(e) { $(`#${e.id}`).remove(), e.insertAfter ? this.html(e.id).insertAfter(e.insertAfter) : e.insertBefore ? this.html(e.id).insertBefore(e.insertBefore) : e.appendTo ? this.html(e.id).appendTo(e.appendTo) : e.prependTo ? this.html(e.id).prependTo(e.prependTo) : console.log("Invalid progress bar location") }
                }, manyResultsReport: {
                    calc(e) { let t = e.reduce((n, i) => (i.status === "fulfilled" && n++, n), 0), a = e.reduce((n, i) => (i.status === "rejected" && n++, n), 0), s = e.filter(n => n.status !== "fulfilled"); return { fulfilled: t, rejected: a, errors: s } }, html(e, t) {
                        let a = this.calc(t); return $(`
                    <div id=${e}>
                        <p><strong>Finished processing</strong></p>
                        <p>Summary:</p>
                        <p>
                            <ul>
                                <li>Failed: ${a.rejected}</li>
                                <li>Succeeded: ${a.fulfilled}</li>
                            </ul>
                        </p>
                    </div>
                `)
                    }, create(e, t) { e.insertAfter ? this.html(e.id, t).insertAfter(e.insertAfter) : e.insertBefore ? this.html(e.id, t).insertBefore(e.insertBefore) : e.appendTo ? this.html(e.id, t).appendTo(e.appendTo) : e.prependTo ? this.html(e.id, t).prependTo(e.prependTo) : console.log("Invalid summary location") }, remove(e) { $(`#${e.id}`).remove() }
                }
            }, this.getSceneSlug = async function (e) { let t = `${this.urlBase}/applications/${this.headers["X-Knack-Application-ID"]}`, n = (await u.one({ url: t, options: { method: "GET" } })).json.application.scenes.find(c => c.key === e); if (!n) throw new Error(`Scene with key ${e} not found, when trying to find corresponding slug (url). Could not continue.`); let i = n.slug; if (!i) throw new Error(`Scene with key ${e} found, but no slug (url) found. Could not continue.`); return i }; function o() {
                if (!r) throw new Error("KnackAPI config settings object not found"); if (!r.auth) throw new Error("KnackAPI.auth configuration not found"); if (r.auth !== "object-based" && r.auth !== "view-based") throw new Error(`KnackAPI.auth invalid - should be "view-based" or "object-based" but got "${r.auth}"`); if (!r.applicationId) throw new Error("KnackAPI.applicationId not found"); if (r.auth === "object-based" && !r.apiKey) throw new Error("Object-based auth selected but did not find an API key"); try {
                    r.auth === "object-based" && Knack && console.log(`
                    Warning! Object-based auth selected but it looks like you are running code in the Knack Javascript area. 
                    We strongly recommend you use view-based auth instead;
                `)
                } catch { }
            }
        } D.exports = z
    }); function U(r, o, e, t) { return { scene: r, view: o, recordId: e, body: t } } function G(r, o, e, t) { return { scene: r, view: o, records: e } } function Y(r, o, e) { return { scene: r, view: o, body: e } } function V(r, o, e) { return { scene: r, view: o, records: e } } function N(r, o, e) { return { scene: r, view: o, recordId: e } } function B(r, o, e, t, a) { if (t) { var s = `https://api.knack.com/v1/pages/${r}/views/${o}/records?${t.name}_id=${t.id}`; return e && (s += "&filters=" + encodeURIComponent(JSON.stringify(e))), s } else { a || (a = "both"); let n = { scene: r, view: o, format: a }; return e && (n.filters = e), n } } function J(r, o, e) { return { recordId: e.id, scene: r, view: o } } var v = { getSingle: (r, o, e) => N(r, o, e), getMany: (r, o, e, t, a) => B(r, o, e, t, a), postSingle: (r, o, e) => Y(r, o, e), postMany: (r, o, e) => V(r, o, e), deleteSingle: (r, o, e) => J(r, o, e), putSingle: (r, o, e, t) => U(r, o, e, t), putMany: (r, o, e, t) => G(r, o, e, t) }; function X(r) { return { match: r, rules: [] } } function L(r) { return { isDuringTheCurrentMonth: { field: r, operator: "is during the current", type: "month" }, isDuringThePreviousMonth: { field: r, operator: "is during the previous", range: "1", type: "months" }, isDuringTheNextMonth: { field: r, operator: "is during the next", range: "1", type: "months" }, isBeforeThePreviousMonth: { field: r, operator: "is before the previous", range: "1", type: "months" } } } var A = { create: r => X(r), common: r => L(r) }; var Q = g(m(), 1); var h = g(m(), 1); async function l() { let r = process.env.KNACK_API_RUNENV; if (r === "browser") return new h.default({ auth: "view-based", applicationId: Knack.application_id, userToken: Knack.getUserToken() }); if (r === "server") { let o = await W(); return new h.default({ auth: "view-based", applicationId: process.env.KNACK_APP_ID, userToken: o }) } } async function W() { let r = new h.default({ auth: "view-based", applicationId: process.env.KNACK_APP_ID }); try { return await r.login({ email: process.env.KNACK_API_LOGIN, password: process.env.KNACK_API_PASSWORD }) } catch (o) { console.log(o) } } async function Z(r) { let o = await l(); console.log("api call started"); try { let e = await o.get(r); return console.log("api call completed"), e.json } catch (e) { return console.log("api call failed", e), null } } async function ee(r) { let o = await l(); console.log("api call started"); try { let e = await o.getMany(r); return console.log("api call completed"), e.records } catch (e) { return console.log("api call failed", e), null } } async function re(r) { let o = r; var e = 1, t = `&page=${e}&rows_per_page=1000`, a = o + t, s = { Authorization: Knack.getUserToken(), "X-Knack-REST-API-Key": "knack", "X-Knack-Application-Id": Knack.application_id, "Content-Type": "application/json" }, n = {}, i = await j(a, s); if (n = { ...i }, i.total_records > 1e3) { let f = i.total_pages; for (var c = 2; c <= f; c++) { var e = c, t = `&page=${e}&rows_per_page=1000`, a = o + t; i = await j(a, s), n.records = [...n.records, ...i.records] } } return n } async function te(r) { let o = await l(); console.log("api call started"); try { let e = await o.postMany(r); return e.summary.rejected > 0 && e.summary.errors.forEach(t => { console.log(JSON.stringify(t.reason)) }), console.log("api call completed"), e } catch (e) { return console.log("api call failed", e), null } } async function oe(r) { let o = await l(); console.log("api call started"); try { let t = (await o.post(r)).json; return console.log("api call completed"), t } catch (e) { return console.log("api call failed", e), null } } async function ae(r) { let o = await l(); console.log("api call started"); try { let t = await (await o.put(r)).json; return console.log("api call completed"), t } catch (e) { return console.log("api call failed", e), null } } async function ne(r) { let o = await l(); console.log("api call started"); try { let e = await o.putMany(r); return e.summary.rejected > 0 && res.summary.errors.forEach(t => { errorHandler(t.reason) }), console.log("api call completed"), e } catch (e) { return console.log("api call failed", e), null } } async function se(r) { let o = await l(); console.log("api call started"); try { let e = await o.delete(r); return console.log("api call completed"), e } catch (e) { return console.log("api call failed", e), null } } async function j(r, o) { console.log("api call started"); try { let t = await (await fetch(r, { method: "GET", headers: o })).json(); return console.log("api call completed"), t } catch (e) { return console.log("api call failed"), console.log("err", e), e } } var E = { getSingle: r => Z(r), getMany: r => ee(r), getManyParentRecord: r => re(r), postSingle: r => oe(r), postMany: r => te(r), putMany: r => ne(r), putSingle: r => ae(r), deleteSingle: r => se(r) }; var M = { isoTo_MMDDYYYY: r => ie(r), isoTo_DDMMYYYY: r => ce(r) }; function ie(r) { return r = new Date(r), { date: r.toLocaleDateString("en-US"), hours: (r.getUTCHours() % 12 || 12).toString().padStart(2, "0"), minutes: r.getUTCMinutes().toString().padStart(2, "0"), am_pm: r.getUTCHours() >= 12 ? "PM" : "AM" } } function ce(r) { return r = new Date(r), { date: r.toLocaleDateString("en-GB"), hours: (r.getUTCHours() % 12 || 12).toString().padStart(2, "0"), minutes: r.getUTCMinutes().toString().padStart(2, "0"), am_pm: r.getUTCHours() >= 12 ? "PM" : "AM" } } var Te = { filters: A, payloads: v, calls: E, utils: M };
})();
//# sourceMappingURL=bundle.js.map
